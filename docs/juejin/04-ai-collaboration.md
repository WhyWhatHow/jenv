# 不会 Go 也能开发 jenv:我的 AI 协作之旅

## 一个不会 Go 的人的野心

故事要从 2024 年的一个想法说起。

我想做一个 Java 版本管理工具 jenv,专门为 Windows 用户优化,比现有的 jenv-for-windows 快 10 倍。

但是,我遇到了一个大问题:**我不会 Go 语言。**

### 传统思维:先学再做

按照传统的开发思路,我应该:

1. 买一本《Go 语言入门》,从头学起
2. 学完基础语法(1-2 个月)
3. 学并发编程、文件操作、跨平台开发(2-3 个月)
4. 然后才能开始写 jenv

**总时间:3-5 个月**,还不一定能写出高质量的代码。

### AI 时代:边做边学

但是,我生活在 2024 年,一个 **AI 协作开发的时代**。

我决定换一个思路:
- **不等完美**,先做起来
- **边做边学**,AI 帮我填补知识空白
- **快速迭代**,从 v0.1 做到 v0.6.7

**Dream big, start small, do it now.**

结果:**6 周时间,从零到发布 v0.6.7。**

这就是我的 AI 协作之旅。

---

## AI 协作编年史

在这 6 周里,我和 5 个 AI 工具深度协作,每个工具都在不同阶段发挥了关键作用。

让我按时间顺序,详细讲述这段旅程。

---

### 第一版:Cursor(快速原型)

**时间**:第 1-2 周
**任务**:搭建基础功能(add/list/use/remove)
**目标**:快速验证想法,做出可用的 v0.1.0

#### 协作方式

**我的角色**:产品经理
- 我不懂 Go,但我知道想要什么
- 我参考 nvm-windows 的设计,描述需求

**Cursor 的角色**:开发工程师
- 生成 Go 代码框架
- 实现基础的 CLI 命令
- 处理文件读写、JSON 配置

#### 典型对话

**我**:
> "我想实现一个 `jenv add` 命令,接收两个参数:别名和 JDK 路径。然后把这个映射关系保存到 JSON 配置文件中。"

**Cursor**:
```go
func AddJDK(alias string, path string) error {
    config := LoadConfig()
    config.JDKs[alias] = path
    return SaveConfig(config)
}
```

**我测试**:
```bash
jenv add java8 "C:\Program Files\Java\jdk1.8.0_291"
jenv list
# 输出:java8 -> C:\Program Files\Java\jdk1.8.0_291
```

**我反馈**:
> "太好了!但是如果路径不存在,应该提示错误。"

**Cursor 修复**:
```go
func AddJDK(alias string, path string) error {
    if !fileExists(path) {
        return fmt.Errorf("JDK path not found: %s", path)
    }
    // ... 原有逻辑
}
```

#### 成果

- ✅ v0.1.0 可用版本,包含 4 个核心命令
- ✅ JSON 配置管理
- ✅ Windows 路径处理

#### 经验教训

**✅ 有效的方法**:
1. **需求描述要具体**:不说"做一个添加功能",而说"接收两个参数,保存到 JSON"
2. **提供参考案例**:参考 nvm-windows 的设计,给 AI 一个方向
3. **快速测试反馈**:立即测试,发现问题马上反馈

**❌ 走过的弯路**:
1. **需求模糊**:最初说"做一个 Java 管理工具",Cursor 生成的代码方向完全不对
2. **盲目信任**:有一次没测试就继续下一步,后来发现前面的代码有 bug,浪费了时间

**关键领悟**:
> **快速迭代比完美设计重要。**先做出来,再优化。

---

### 第二版:OpenAI GPT-4(讨论与重构)

**时间**:第 3 周
**任务**:代码重构、架构优化
**目标**:让代码更清晰、更易维护

#### 协作方式

**我的角色**:代码审查者
- 把 Cursor 生成的代码贴给 GPT-4
- 问"如何优化这段代码?"

**GPT-4 的角色**:架构顾问
- 建议设计模式
- 指出代码坏味道
- 提供最佳实践

#### 典型对话

**我**:
> 我的 `config.go` 现在有 300 行,全局变量满天飞,怎么优化?

**GPT-4**:
> 建议使用**单例模式**管理配置:
> 1. 创建 `ConfigManager` 结构体
> 2. 使用 `sync.Once` 保证只初始化一次
> 3. 提供 `GetInstance()` 方法获取单例
>
> 这样可以:
> - 避免全局变量
> - 线程安全
> - 延迟初始化

**我**:理解了思路,回到 Cursor 实现:

```go
type ConfigManager struct {
    config *Config
    mu     sync.RWMutex
}

var (
    instance *ConfigManager
    once     sync.Once
)

func GetInstance() *ConfigManager {
    once.Do(func() {
        instance = &ConfigManager{
            config: loadConfig(),
        }
    })
    return instance
}
```

#### 成果

- ✅ 代码结构更清晰,模块化
- ✅ 使用设计模式(单例、工厂)
- ✅ 线程安全的配置管理

#### 经验教训

**✅ 有效的方法**:
1. **贴完整代码**:让 GPT-4 看到全貌,才能给出好建议
2. **问开放性问题**:"如何优化"比"这样对吗"更有价值
3. **理解思路再实现**:不直接复制 GPT-4 的代码,而是理解后用 Cursor 实现

**❌ 走过的弯路**:
1. **过度设计**:GPT-4 建议了 5 种设计模式,我全用上了,结果代码变得过于复杂
2. **脱离实际**:有些建议很学术,但不适合这个项目规模

**关键领悟**:
> **AI 是好的 code reviewer,但你要保持主导权。** 不是所有建议都要采纳,选择适合项目的。

---

### 第三版:Trae(UI 美化)

**时间**:第 4 周
**任务**:TUI 界面、主题系统
**目标**:让 CLI 看起来现代化、用户友好

#### 协作方式

**我的角色**:UX 设计师
- 提出界面需求:"要彩色输出、暗色主题"
- 提供视觉参考:其他优秀 CLI 工具的截图

**Trae 的角色**:前端工程师
- 集成 Lipgloss 库
- 设计配色方案
- 实现主题切换

#### 典型对话

**我**:
> 我想让 `jenv list` 的输出更好看,加上颜色、图标。

**Trae**:
> 可以使用 Charm 的 Lipgloss 库:
>
> ```go
> import "github.com/charmbracelet/lipgloss"
>
> titleStyle := lipgloss.NewStyle().
>     Bold(true).
>     Foreground(lipgloss.Color("#00FF00"))
>
> fmt.Println(titleStyle.Render("📋 Installed Java versions:"))
> ```

**我测试后**:
> 绿色太亮了,能不能柔和一点?

**Trae 调整**:
> 改用 `#7CFC00`,并加上主题系统,支持浅色/深色模式。

#### 成果

- ✅ 现代化的 CLI 界面
- ✅ 支持浅色/深色主题
- ✅ 彩色输出、图标、进度条

#### 经验教训

**✅ 有效的方法**:
1. **提供视觉参考**:截图比文字描述更清晰
2. **迭代调整**:第一版不完美没关系,慢慢调
3. **用户体验同样重要**:好看的工具让人更愿意用

**关键领悟**:
> **不要忽视 UI/UX,即使是 CLI 工具。** 好的用户体验能提升工具的吸引力。

---

### 第四版:Gemini(性能优化)

**时间**:第 5-6 周
**任务**:scan 性能从 3s 优化到 300ms
**目标**:实现 10 倍性能提升

#### 协作方式

**我的角色**:性能工程师
- 贴出 `scan` 函数代码
- 说明性能问题:"扫描 C 盘太慢,需要 3 秒"

**Gemini 的角色**:优化专家
- 分析性能瓶颈
- 建议并发模型
- 生成优化代码

#### 典型对话

**我**:
> 我的 scan 函数太慢了,怎么优化?
>
> ```go
> func Scan(root string) []JDK {
>     var results []JDK
>     filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
>         if strings.HasSuffix(path, "javac.exe") {
>             results = append(results, parseJDK(path))
>         }
>         return nil
>     })
>     return results
> }
> ```

**Gemini**:
> 问题在于 `filepath.Walk` 是**顺序遍历**,像 1 个人搜整个图书馆。
>
> 建议使用 **Dispatcher-Worker 并发模型**:
> 1. Dispatcher 将 C 盘分成多个顶层目录
> 2. 启动多个 Worker goroutine,并发扫描每个目录
> 3. 使用 channel 收集结果
>
> 预期性能提升:**5-10 倍**

**我**:听起来很棒!能给个代码框架吗?

**Gemini**:
```go
func ScanConcurrent(root string) []JDK {
    results := make(chan JDK, 10)
    var wg sync.WaitGroup

    dirs := getTopLevelDirs(root)
    for _, dir := range dirs {
        wg.Add(1)
        go func(d string) {
            defer wg.Done()
            scanDir(d, results)
        }(dir)
    }

    go func() {
        wg.Wait()
        close(results)
    }()

    return collectResults(results)
}
```

**我理解了概念**,回到 Cursor 完善细节:
- 添加智能过滤(跳过 `Windows`、`AppData` 等)
- 添加进度条显示
- 处理边界情况(空目录、权限不足)

#### 成果

- ✅ 扫描时间:3s → **300ms**(90% 提升!)
- ✅ 实现 Dispatcher-Worker 模型
- ✅ 智能过滤,跳过无用目录

#### 经验教训

**✅ 有效的方法**:
1. **量化问题**:"太慢"不如"需要 3 秒"具体
2. **理解概念再实现**:Gemini 解释了 Dispatcher-Worker 模型,我理解后再写代码
3. **结合工具**:Gemini 提供思路,Cursor 完善细节

**❌ 走过的弯路**:
1. **直接复制代码**:第一次直接复制 Gemini 的代码,结果在 Windows 上运行失败(路径问题)
2. **忽视边界情况**:没考虑权限不足的情况,导致程序崩溃

**关键领悟**:
> **AI 擅长性能优化建议,但细节要自己把控。** 理解原理比复制代码重要。

---

### 全程:Claude(整体协作)

**时间**:整个开发过程
**任务**:架构设计、文档撰写、这篇文章
**目标**:深度思考、方案权衡

#### 协作方式

**我的角色**:产品负责人
- 和 Claude 进行深度对话
- 讨论设计决策
- 权衡不同方案

**Claude 的角色**:架构顾问 + 文档助手
- 提供架构建议
- 帮助撰写 README
- 撰写这篇文章

#### 典型对话

**我**:
> jenv 应该用符号链接还是环境变量?

**Claude**:
> 让我们权衡一下:
>
> **符号链接**:
> - ✅ 性能:零开销,直接指向
> - ✅ 跨平台:Windows/Linux/macOS 都支持
> - ❌ 复杂度:需要管理员权限(Windows)
>
> **环境变量**:
> - ✅ 简单:不需要特殊权限
> - ❌ 性能:每次切换要修改注册表/配置文件
> - ❌ 生效:需要重启终端
>
> **建议**:使用符号链接,因为:
> 1. 性能更重要(这是核心卖点)
> 2. 一次性管理员权限可以接受
> 3. 跨平台更统一

**我**:有道理!那权限问题怎么处理?

**Claude**:
> 可以这样设计:
> 1. `jenv init` 时一次性申请权限
> 2. 之后所有操作都不需要权限
> 3. 给用户清晰的提示,解释为什么需要权限

**我**:完美!

#### 成果

- ✅ 清晰的架构决策
- ✅ 完善的 README 文档
- ✅ 这篇文章(你正在读的)

#### 经验教训

**✅ 有效的方法**:
1. **深度对话**:不是简单问答,而是讨论、权衡
2. **多问"为什么"**:理解决策背后的原因
3. **文档也很重要**:好的文档让更多人能用你的工具

**关键领悟**:
> **AI 是思维伙伴。** 不只是写代码,更重要的是帮你思考。

---

## AI 协作方法论

经过 6 周的实践,我总结出一套 **AI 协作开发方法论**。

### 零基础学习的三步法

如果你也想用 AI 学习一门新技术,可以参考我的经验:

#### Step 1:AI 生成代码 → 我运行测试

- AI 生成代码框架
- 我运行,看看效果
- 如果失败,反馈错误信息给 AI

**案例**:
- Cursor 生成 `jenv add` 函数
- 我测试,发现路径有空格时报错
- 反馈给 Cursor,它添加了引号处理

#### Step 2:遇到问题 → AI 解释原理

- 运行中遇到概念不懂
- 问 AI:"这是什么意思?"
- AI 解释,我理解

**案例**:
- Gemini 建议用 goroutines
- 我问:"goroutines 和线程有什么区别?"
- Gemini 解释:goroutines 更轻量,Go 的调度器管理
- 我理解了,继续

#### Step 3:理解概念 → 自己改代码

- 理解了原理
- 自己尝试修改代码
- 如果卡住,再问 AI

**案例**:
- 理解了 Dispatcher-Worker 模型
- 我自己添加了智能过滤逻辑
- 添加进度条时不会,问 Cursor,它给了示例

### 结果

**从不懂 Go 到能写出高性能代码,我只用了 6 周。**

关键在于:**不等完美,边做边学。**

---

### 高效协作的五个技巧

经过实践,我总结了 5 个提高 AI 协作效率的技巧:

#### 技巧 1:描述需求要具体(附参考案例)

❌ **不好**:"做一个 Java 管理工具"
✅ **好**:"做一个工具,类似 nvm-windows,但管理 Java 版本。要有 add/list/use/remove 命令。"

**为什么**:具体的需求 + 参考案例,AI 才知道你想要什么。

#### 技巧 2:分模块迭代(不求一步到位)

❌ **不好**:"做一个完美的 Java 管理工具,包含所有功能"
✅ **好**:
- Week 1-2:基础功能(add/list/use/remove)
- Week 3:重构优化
- Week 4:UI 美化
- Week 5-6:性能优化

**为什么**:分模块迭代,每一步都能看到成果,及时调整方向。

#### 技巧 3:主动提问(不懂就问)

❌ **不好**:看到陌生概念(goroutines),假装懂了,继续往下
✅ **好**:立即问:"goroutines 是什么?和线程有什么区别?"

**为什么**:AI 不会嫌你问题多。主动提问,才能真正学到东西。

#### 技巧 4:多 AI 互补(各有所长)

- **Cursor**:写代码快,适合快速原型
- **GPT-4**:架构设计,适合讨论方案
- **Gemini**:性能优化,适合技术深入
- **Trae**:UI/UX,适合界面设计
- **Claude**:深度思考,适合文档和文章

**为什么**:每个 AI 有自己的强项,组合使用效果最好。

#### 技巧 5:保持主导权(你是 PM)

❌ **不好**:AI 说什么就做什么,完全依赖
✅ **好**:
- AI 提供建议
- 我权衡利弊
- 我做最终决策

**为什么**:AI 是助手,不是老板。你才是项目负责人。

---

### 避坑指南

分享 4 个我踩过的坑,希望你能避开:

#### 坑 1:盲目信任 AI 代码(要测试)

**我的教训**:
- Cursor 生成了 `scan` 函数
- 我没测试,就继续做下一步
- 后来发现有 bug,浪费了半天时间

**正确做法**:
- AI 生成代码后,**立即测试**
- 测试通过,再继续
- 边界情况也要测(空输入、特殊字符)

#### 坑 2:不理解就复制(会卡住)

**我的教训**:
- Gemini 给了一段并发代码
- 我不理解 `sync.WaitGroup`,直接复制
- 后来要改功能,完全不知道从哪下手

**正确做法**:
- 遇到不懂的,**先问清楚**
- 理解了原理,再写代码
- 不理解的代码,就是技术债

#### 坑 3:需求描述模糊(得不到想要的)

**我的教训**:
- 我说"做一个扫描功能"
- Cursor 生成的代码完全不是我想要的
- 来回改了 5 次

**正确做法**:
- **具体**:"扫描 C 盘所有 `javac.exe`,返回 JDK 路径列表"
- **附参考**:"类似 nvm-windows 的扫描"
- **举例子**:"比如找到 `C:\Program Files\Java\jdk1.8.0_291\bin\javac.exe`,应该返回 `C:\Program Files\Java\jdk1.8.0_291`"

#### 坑 4:过度依赖(失去学习机会)

**我的反思**:
- AI 可以生成所有代码
- 但如果完全依赖,我就学不到东西
- 下次遇到类似问题,还是不会

**正确做法**:
- 用 AI 加速学习,不是替代学习
- 关键概念,要自己理解
- 尝试自己写代码,卡住再问 AI

---

## AI 时代的观点

通过这 6 周的开发,我对 AI 时代有了一些深刻的体会。

### 技术民主化

**过去**:
- 想做一个项目,需要多年编程经验
- 新手只能从简单项目开始,慢慢积累
- 很多想法因为技术门槛太高,永远停留在想法阶段

**现在**:
- 有想法,AI 帮你实现
- 新手也能做出复杂项目
- **技术不再是障碍,创意才是关键**

**意义**:
- 更多人能解决自己的问题
- 更多创新的工具诞生
- 技术真正服务于人,而不是少数精英

**我的案例**:
- 我不会 Go,但 6 周做出了 jenv
- jenv 解决了我自己的痛点
- 现在也帮助了其他 Java 新手

### 个人定制化

**理念**:每个人都可以做私人定制。

**过去**:
- 发现一个工具不好用,只能忍受或换一个
- 提 Issue,等维护者修复,可能等几个月

**现在**:
- 不喜欢?自己改
- AI 帮你实现定制功能
- **改变你不喜欢的东西,变得异常容易**

**我的案例**:
- jenv-for-windows 太慢,我不满意
- 我没有等,而是自己做了一个快 10 倍的
- 现在 Windows 用户有了更好的选择

**鼓励**:
- 不要等别人解决你的问题
- AI 时代,你可以自己动手
- **Be the change you want to see**

### Dream Big, Start Small

**Dream Big**(敢想):
- 我想做一个比现有工具快 10 倍的工具
- 这在过去是疯狂的想法(不会 Go,怎么可能?)
- 但在 AI 时代,这是可实现的目标

**Start Small**(小步走):
- 不求一步到位
- Week 1-2:基础功能
- Week 3:重构
- Week 4:美化
- Week 5-6:优化
- v0.1 → v0.6.7,**逐步迭代**

**Do It Now**(立即行动):
- 不等完美
- 不等学会 Go
- **先做起来**,边做边学

**迭代过程**:
- v0.1.0:基础功能,能用但慢
- v0.3.0:重构后,代码清晰了
- v0.4.0:界面好看了
- v0.6.7:性能提升 10 倍,发布!

**关键领悟**:
> **完成比完美更重要。** 先发布 v0.1,在使用中迭代,比一直憋着要好。

---

## 结尾:你也可以

看到这里,你可能会想:

> "你能做到,是因为你有编程基础。我完全不会编程,能行吗?"

我的答案:**能!**

### 为什么你也可以

1. **AI 比你想象的更强大**
   - 它可以解释每一行代码
   - 它可以从零开始教你
   - 它不会嫌你问题多

2. **关键不是技术,是想法**
   - 你知道自己的痛点
   - 你知道想要什么
   - 这些 AI 不知道,只有你知道

3. **工具都是免费/便宜的**
   - Cursor:免费版足够用
   - ChatGPT:免费版也很强
   - Claude/Gemini:都有免费额度

### 从解决自己的痛点开始

**不要一开始就想做大项目。**

从小问题开始:
- 每天重复的操作?写个脚本自动化
- 某个工具不好用?改一改
- 有个小想法?试试看

**jenv 就是从我的痛点开始的:**
- 我不喜欢手动改环境变量
- 我不满意 jenv-for-windows 的速度
- 我想要一个专门为 Windows 优化的工具

### 行动建议

如果你也想尝试 AI 协作开发,我的建议:

1. **选一个小项目**:
   - 解决你自己的问题
   - 范围明确,不要太大
   - 1-2 周能完成

2. **选一个 AI 工具开始**:
   - Cursor:适合写代码
   - ChatGPT:适合讨论方案
   - 选一个,先上手

3. **边做边学**:
   - 不等完美
   - 遇到问题,问 AI
   - 做出来,再优化

4. **分享你的故事**:
   - 发布在 GitHub
   - 写一篇文章
   - 帮助更多人

---

## 现在就开始

🚀 **试试 jenv**:
- GitHub:[github.com/WhyWhatHow/jenv](https://github.com/WhyWhatHow/jenv)
- Landing Page:[jenv-win.vercel.app](https://jenv-win.vercel.app)
- 文档:[完整指南](https://github.com/WhyWhatHow/jenv#usage)

⭐ **给 jenv 一个 star**:
- 让更多人看到这个故事
- 鼓励我继续优化
- Star 数就是最好的支持!

💬 **分享你的 AI 协作故事**:
- 在评论区说说你的经历
- 你用 AI 做过什么项目?
- 遇到了什么挑战?

---

**Happy coding! 愿你在 AI 时代,敢想敢做,创造属于自己的工具!✨**

---

> **系列文章回顾**:
> 1. [曾经淋过雨,现在想为你撑伞:jenv 诞生记](01-why-jenv.md)
> 2. [5 分钟从零到 Hello World:jenv 极速上手](02-quick-start.md)
> 3. [为什么 jenv 比 jenv-for-windows 快 10 倍?](03-technical-deep-dive.md)
> 4. [不会 Go 也能开发 jenv:我的 AI 协作之旅](04-ai-collaboration.md) *(你正在读的)*
